/*
问题描述：
在MM-21星球上，今年的奥运会结束后，冰壶运动越来越受欢迎。但这些规则与我们的规则有些不同。
该游戏在冰上游戏板上进行，该板上标记了方形网格。他们只使用一块石头。游戏的目的是以最少的移动次数将石头从起点引导到目标。

图 1 显示了一个游戏板的示例。一些广场可能会被方块占据。有两个特殊的方块，即起点和目标，它们没有被方块占据。
（这两个正方形是不同的。一旦石头开始移动，它就会继续，直到它撞到一个方块。为了将石头带到目标，您可能必须通过击中块来阻止石头，然后再次投掷。


图1：板示例（S：开始，G：目标）

石头的运动遵循以下规则：

一开始，石头在起点广场上静止不动。
石头的运动仅限于x和y方向。禁止对角线移动。
当石头静止不动时，你可以通过投掷它来使它移动。你可以把它扔到任何方向，除非它立即被阻挡（图2（a））。
投掷后，石头会继续向同一方向移动，直到发生以下情况之一：
石头撞到一个方块（图2（b），（c））。
石头停在它所击中的方块旁边的广场上。
块将消失。
石头从棋盘上掉了出来。
游戏以失败告终。
石头到达目标广场。
石头停在那里，游戏以成功告终。
在一场比赛中，你不能扔石头超过10次。如果石头在10步中没有到达目标，游戏就会以失败告终。
图2：石头运动
根据规则，我们想知道开始时的石头是否可以达到目标，如果是，则需要最少的移动次数。
根据图 1 中所示的初始配置，需要 4 次移动才能将宝石从起点带到目标。路线如图3（a）所示。请注意，当石头到达目标时，电路板配置已更改，如图3（b）所示。
图3：图解D-1 和最终电路板配置
*
求解思路：
（1）首先读取地图，保存到map数组中，并找到起点设置为sx和sy 
（2）然后对地图进行bfs搜索 ，终止的条件有两个，（1）找到终点 （2）步数超过十步 
（3）dir[4][2]数组表示方向的移动，分别是上左下右 ，用dir数组来预判下一步的位置 ，每次搜索都有这四种不同的方向 
（4）其中if(tx < 0 || tx >= h || ty < 0 || ty >= w)语句用来判断是否出界，出界就要进行下一个方向的判断  
     没有越界就要判断是不是遇到墙了，遇到墙就停止滑动，开始进行深搜，先消除障碍将该点设为0、下一步搜索后，然后再重建障碍 
（5）直到找到终点或者超出十步。 
	   
*
提交状态：AC
*
AC结果：
212K	110MS

*
出错次数：
5、6次
错误结果：
对回溯算法掌握的不牢固，对一些C++自带函数认识不全，不懂得使用方法。 
测试数据的范围不准确认知，对数据的范围和特殊值把握不准

*/
#include <iostream>
#include <algorithm>
#include <cstdio>
using namespace std;
const int Max = 20 + 10;
int map[Max][Max];
int dir[4][2] = {{-1,0},{0,-1},{1,0},{0,1}}; 
int flag; 
int minStep; 
int w,h;
void dfs(int x, int y, int step)
{
 
	int nx,ny;
	int tx,ty;
	int px,py;
	if(step > 10)
	{
		return;
	}
	if(map[x][y] == 3)
	{
 
		minStep = min(minStep, step); 
		return;
	}
	for(int i=0; i<4; i++)
	{
		tx = x + dir[i][0];
		ty = y + dir[i][1];
		nx = x;
		ny = y;
	 
		while(tx >= 0 && tx < h && ty >= 0 && ty < w && map[tx][ty] != 1) 
		{
			nx += dir[i][0];
			ny += dir[i][1];
 
			if(map[nx][ny] == 3) 
			{
 
				minStep = min(minStep, step); 
				return;
			}

			tx = nx + dir[i][0];
			ty = ny + dir[i][1];

		 	if(tx < 0 || tx >= h || ty < 0 || ty >= w)
				  break; 
			if(map[tx][ty] == 1) 
			{
				map[tx][ty] = 0; 
				dfs(nx, ny, step+1);
				map[tx][ty] = 1; 
			}
		}
		
	}
}
int main()
{
	int sx,sy;
	while(scanf("%d %d",&w,&h) != EOF && w != 0 && h != 0)
	{
		minStep = 10000;
		for(int i=0; i<h; i++)
		{
			for(int j=0; j<w; j++)
			{
				scanf("%d",&map[i][j]);
				if(map[i][j] == 2) //起点 
				{
					sx = i;
					sy = j;
				}
			}
		}
		dfs(sx, sy, 1); 
		if(minStep == 10000)
			cout<<"-1"<<endl;
		else
			cout<<minStep<<endl;
	}
	return 0;
}
